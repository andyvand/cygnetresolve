# netresolve library and tools

## Core features

 * Backend-based network name resolution similar to that one found in glibc's nsswitch
   - Configurable backend options
 * Avoids many limitations and bugs found in glibc, getaddrinfo and nsswitch
   - Synchronous and asynchronous (aka non-blocking) API
   - Extensible request and result API
   - Support for ifindex/scope_id (problematic in nsswitch)
   - Support for TTL information (problematic in nsswitch)
 * Compatibility measures
   - Compatibility backends (see below)

## Basic (synchronous) API

The application creates a resolver instance using `netresolve_open()`, optionally performs additional configuration, and then calls `netresolve_resolve()` and uses retrieve the result using `netresolve_get_*()` functions.

This is functionally similar to `getaddrinfo()` except that the resolver object is used for advanced configuration not supported by `netresolve_resolve()`. That's much more flexible than only supporting environment variables for advanced configuration, but they can still be used to tweak the default values.

## Callback-based (asynchronous) API

How to use it:

1. Create a handle using `netresolve_open()`.
2. Register callbacks using `netresolve_set_watch_fd()` and/or `netresolve_set_callback_*()`.
3. Run netresolve_resolve().

What should the callbacks do:

1. The `watch_fd()` callback is there to add/remove the netresolve's file descriptor
2. The `on_success()` callback is called when the name resolution finished without error.
3. The `on_failure()` callback is called when the name resolution failed.

The `watch_fd()` callback is only needed for asynchronous operation. A `watch_fd()` call with *events* equal to zero must result in removing the respective file descriptor from the main loop.

You can use the `on_success()` and `on_failure()` callbacks synchronously as well, setting the `watch_fd()` callback activates asynchronous behavior.

Implementation notes:

The current implementation only registers *one* file descriptor with the application. The file descriptor is an *epoll* file descripter and the associated event is allways `POLLIN`. It's used for tracking the file descriptors that are attached to it and can be used with `select()`, `poll()` as well as `epoll()`. On platforms without *epoll*, a similar mechanism can be used if available or the individual backend file descriptors can be conveyed to the application for use with standard `select()`, `poll()` and similar. A portable application shouldn't rely

## Utility functions

They currently mainly serve as examples of how to use `netresolve_resolve()` together with system calls like `bind()` or `connect()`.

## Tools

The `netresolve` command-line tool can be used for testing the library. The `libnetresolve-getaddrinfo.so` library together with the `tools/wrapper.sh` script can be used to test any programs calling `getaddrinfo()` (see `TODO` for missing features).

## Backends

The list of backends can be chosen using `netresolve_set_backend_string()` or via the `NETRESOLVE_BACKENDS` environment variable. Backends are separated by a comma and accept options separated by a colon. A plus sign prepended to the backend name can be used to run that backend even if another backend already succeeded.

    NETRESOLVE_BACKENDS=null,numerichost,hosts,services

### Local backends

Two backends, `null` and `numerichost`, are available that perform trivial translations. The `hosts` backends uses `/etc/hosts` database of nodes. The special `services` backend fills in service information using `/etc/services`.

### Remote backends

Nonblocking API is most useful for remote services. Currently there's `dns` backend based on *c-ares* with support for quick partial responses when only IPv4 (or, theoretically, only IPv6) query gets answered.

### Compatibility backends

The `getaddrinfo` backend calls glibc's `getaddrinfo()` to get all the
information. The `nss` backend calls glibc's nsswitch backends directly.

    NETRESOLVE_BACKENDS=getaddrinfo ./netresolve www.sourceware.org http

    NETRESOLVE_BACKENDS=nss:files ./netresolve localhost

There's also a `exec` backend that calls an executable and feeds it with the
serialized request on standard input and expect a serialized response on
standard output.

    NETRESOLVE_BACKENDS=exec:/path/to/my/script ./netresolve localhost

TODO: That backend isn't finished, yet.

## Writing a custom backend

When a name resolution request is ready, netresolve calls `start(resolver, settings)`. Backend's `start()` implementation then has to do one of the following:

1. Add any data items using `netresolve_backend_add_*()` functions and call `netresolve_backend_finished()` to signal that the name resolution has finished and we don't need to run any other backends.
2. Call `netresolve_backend_failed()` to signal failure.
3. Add one or more file descriptors or timers using `netresolve_backend_watch_fd()` and `netresolve_backend_watch_timeout()`. In that case, the backend must also provide the `dispatch()` function to continue the request.

Input data is gathered using `netresolve_backend_get_*()` functions. Internal state accross `start()` and `dispatch()` calls can be kept using `netresolve_backend_new_priv()` and `netresolve_backend_get_data()`. The backend should provide `cleanup()` function to clean up any resources either after success/failure, or when the transaction was cancelled by the application.

## Acknowledgements and inspiration

### The community

TODO: Add actual names.

### c-ares

They provide `ares_fds()` and `ares_timeout()` to update the current set of file descriptors and the associated timeout. The `netresolve` callback API improves greatly on that. The application submits the `watch_fd()` callback.

### sssd

They provide a backend-based caching service for user/group name resolution, authentication and related stuff. As netresolve doesn't really need to cache its results nor does it need to perform authentication services, it provides just a shared library, not a long-running daemon. Also, for DNS resolution they currently use `c-ares`.

### libevent, squid, etc...

According to the website, libevent is using internal asynchronous DNS as well. The same applies to squid. Apparently the operating system's resolution API is not sufficient for many tools.

## License

Copyright (C) 2013 Pavel Å imerda, Red Hat, Inc. (psimerda at redhat.com) and others

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
