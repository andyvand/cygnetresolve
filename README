# netresolve library and tools

## Core features

 * File descriptor based nonblocking host/service name resolution API
   - suitable for various file descriptor based event loops
   - unlike glibc or POSIX APIs
 * Extensible request and result APIs
   - DNS SRV records
   - unlike glibc or POSIX APIs
 * Backend-based network name resolution similar to that one found in glibc's nsswitch
   - configurable backend options
   - unlike DNS-only libraries
 * Avoids limitations and bugs found in glibc
   - support for ifindex/scope\_id (problematic in nsswitch)
   - support for TTL information (problematic in nsswitch)
 * DNS happy eyeballs implementation
   - concurent A/AAAA requests
   - quick timeout when there's no answer to one of A/AAAA requests
 * Socket API
   - callback based wrappers over `socket()`, `bind()` and `connect()`
   - the application receives a successfully bound or connected socket
 * TCP happy eyeballs implementation
   - concurrent IPv4/IPv6 connect
   - quick timeout when there's no answer to one of IPv4/IPv6 TCP SYN packets

## Blocking API

The application creates a channel using `netresolve_open()` and  optionally performs additional configuration. Then it creates a query instance `netresolve_query()`. By default this call blocks until the query is finished and the application can immediately use `netresolve_query_get_*()` functions to retrieve the query result bits.

When you're finished, call `netresolve_close()` to free the channel and the related query objects.

## Nonlocking API

Before calling `netresolve_query()` the application can register a file descriptor callback to provide netresolve a means to register and unregister file descriptors and their associated events. That is done using `netresolve_set_fd_callback()` and has a side effect of turning `netresolve_query()` into a nonblocking call.

The application can simply include the file descriptor(s) acquired using the file descriptor callback in its event loop and call `netresolve_dispatch_fd()` on the channel whenever a file descriptor is ready. For simplicity, the `netresolve_dispatch_fd()` just returns `false` if the file descriptor is not recognised, `true` otherwise.

After `netresolve_query()`, at least one file descriptor is registered with the application. When all file descriptors are unregistered, the library has finished its work. But the application typically needs to process queries as they are finished and that's where `netresolve_set_success_callback()` (usable with the blocking API as well) gets handy.

Limitations:

 * You can currently only run one query at a time on one channel.
 * There's no real error reporting, yet.
 * The API requires nonstandard OS features such as timerfd.
 * The implementation requires additional features like epoll.

Implementation notes: The current implementation only registers *one* file descriptor with the application. The file descriptor is an *epoll* file descripter and the associated event is allways `POLLIN`. It's used for tracking the file descriptors that are attached to it and can be used with `select()`, `poll()` as well as `epoll()`.

## Classic API (POSIX and some nonstandard libc APIs)

If your program doesn't need the full power of the provided API but you still want to use `netresolve` as your resolver implementation, you can simply link your program to `libnetresolve-libc.so` which overrides selected libc name resolution functions.

Supported functions:

 * `getaddrinfo()`
 * `gethostbyname()`

## Socket API

Support for `socket()`, `bind()` and `connect()` is included. The only thing the application has to do is to register either `on_bind()` or `on_connect()` callback. The resolver is configured with flags suitable for the respective operation. When name resolution is finished, `on_bind()` callback is called for each successfully bound address. The `on_connect()` callback is called once, for the first successfully connected address.

## Tools

The `netresolve` command-line tool can be used for testing the library. The `libnetresolve-libc.so` library together with the `tools/wrapper.sh` script can be used to test any programs calling `getaddrinfo()` and similar.

## Backends

The list of backends can be chosen using `netresolve_set_backend_string()` or via the `NETRESOLVE_BACKENDS` environment variable. Backends are separated by a comma and accept options separated by a colon. A plus sign prepended to the backend name can be used to run that backend even if another backend already succeeded.

    NETRESOLVE_BACKENDS=any,loopback,numerichost,hosts,dns

### Production backends

Three backends, `any`, `loopback` and `numerichost`, are available that perform trivial translations. The `hosts` backends uses `/etc/hosts` database of nodes. Nonblocking API is most useful for remote services. Currently there's a nonblocking `dns` backend based on the *c-ares* library.

### Testing backends

The `getaddrinfo` backend calls glibc's `getaddrinfo()` to get all the information. The `nss` backend calls glibc's nsswitch backends directly. Both of those backends are blocking as the underlying functions are blocking as well.

    NETRESOLVE_BACKENDS=getaddrinfo ./netresolve www.sourceware.org http

    NETRESOLVE_BACKENDS=nss:files ./netresolve localhost

There's also a nonblocking `exec` backend that calls an executable and feeds it with the serialized request on standard input and expect a serialized response on standard output.

    NETRESOLVE_BACKENDS=exec:/path/to/my/script ./netresolve localhost

That one can be used for interactive testing as well:

    NETRESOLVE_BACKENDS=exec:socat:-:/dev/tty ./netresolve www.example.com

## Writing a custom backend

When a name resolution request is ready, netresolve calls `start(resolver, settings)`. Backend's `start()` implementation then has to do one of the following:

1. Add any data items using `netresolve_backend_add_*()` functions and call `netresolve_backend_finished()` to signal that the name resolution has finished and we don't need to run any other backends.
2. Call `netresolve_backend_failed()` to signal failure.
3. Add one or more file descriptors or timers using `netresolve_backend_watch_fd()` and `netresolve_backend_watch_timeout()`. In that case, the backend must also provide the `dispatch()` function so that the transaction can continue.

Input data is gathered using `netresolve_backend_get_*()` functions. Internal state accross `start()` and `dispatch()` calls can be kept using `netresolve_backend_new_priv()` and `netresolve_backend_get_data()`. The backend should provide `cleanup()` function to clean up any resources. It's called by netresolve upon success/failure or when the transaction was cancelled by the application.

## Known bugs

The library doesn't currently sort paths according to their priority and/or RFC rules. The DNS backend doesn't support search domains. For more information, see the `TODO` file.

## Acknowledgements and inspiration

 * Tore Anderson was the first who discussed name resolution issues with me and especially the reasons to suppress A or AAAA queries when global address of the respective family is not present in the system.
    - [sourceware.org: #12377](https://sourceware.org/bugzilla/show_bug.cgi?id=12377)
 * Simo Sorce told me about `getaddrinfo()` issues with canonical names.
 * Ulrich Drepper wrote a good amount of documentation on network name resolution.
    - [Userlevel IPv6 Programming Introduction](http://www.akkadia.org/drepper/userapi-ipv6.html)
    - [Asynchronous Hostname Lookup API](http://www.akkadia.org/drepper/asynchnl.pdf)
 * Carlos O'Donnel helped me to find my way in the glibc community.
 * Nick Jones brought in the idea of a file descriptor based nonblocking API.
    - [libc-alpha: asynchronous getaddrinfo and getnameinfo](https://sourceware.org/ml/libc-alpha/2013-01/msg00356.html)
    - [fedora-devel: asynchronous name resolution requirements](https://lists.fedoraproject.org/pipermail/devel/2013-January/177290.html)
 * Petr Špaček pointed me to SSSD developers.
 * Jakub Hrozek told me about c-ares DNS library and about SSSD name resolution requirements.
    - https://fedorahosted.org/sssd/ticket/2155
 * Miloslav Trmač reminded me of the need to also provide binding and connecting facilities on top of name resolution.
 * Lennart Poettering wrote *libasyncns*, an async wrapper over libc resolver functions

## Related projects

### c-ares

They provide `ares_fds()` and `ares_timeout()` to update the current set of file descriptors and the associated timeout. The `netresolve` callback API improves greatly on that. The application submits the `watch_fd()` callback.

### sssd

They provide a backend-based caching service for user/group name resolution, authentication and related stuff. As netresolve doesn't really need to cache its results nor does it need to perform authentication services, it provides just a shared library, not a long-running daemon. Also, for DNS resolution they currently use `c-ares`.

### libevent, squid, etc...

According to the website, libevent is using internal asynchronous DNS as well. The same applies to squid. Apparently the operating system's resolution API is not sufficient for many tools.

## License

Copyright (c) 2013 Pavel Šimerda, Red Hat, Inc. (psimerda at redhat.com) and others
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
